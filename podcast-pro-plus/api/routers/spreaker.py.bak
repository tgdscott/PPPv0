from fastapi import APIRouter, Depends, HTTPException, status, Body, Request
from fastapi.concurrency import run_in_threadpool
from fastapi.responses import HTMLResponse
from pydantic import BaseModel
from sqlalchemy.orm import Session
from ..core.database import get_session
from ..core.config import settings
from ..core import crud
from ..models.user import User
from ..services.publisher import SpreakerClient
from .auth import get_current_user
import httpx
from pathlib import Path
from typing import Optional
from urllib.parse import urlencode
import secrets
from uuid import UUID

# Define the Pydantic model at the top of the file
class SpreakerUploadRequest(BaseModel):
    show_id: str
    title: str
    filename: str
    description: Optional[str] = None
    auto_published_at: Optional[str] = None

UPLOAD_DIR = Path("temp_uploads")
CLEANED_DIR = Path("cleaned_audio")
EDITED_DIR = Path("edited_audio")
OUTPUT_DIR = Path("final_episodes")

def find_file_in_dirs(filename: str) -> Optional[Path]:
    for directory in [UPLOAD_DIR, CLEANED_DIR, EDITED_DIR, OUTPUT_DIR]:
        path = directory / filename
        if path.exists():
            return path
    return None

router = APIRouter(
    prefix="/spreaker",
    tags=["Spreaker"],
)

_oauth_states = {}

@router.get("/auth/login")
async def spreaker_login(request: Request, current_user: User = Depends(get_current_user)):
    state = secrets.token_urlsafe(32)
    _oauth_states[state] = {"user_id": str(current_user.id)}
    params = {
        "client_id": settings.SPREAKER_CLIENT_ID,
        "response_type": "code",
        "redirect_uri": settings.SPREAKER_REDIRECT_URI.replace("localhost", "127.0.0.1"),
        "scope": "basic",
        "state": state
    }
    auth_url = f"https://www.spreaker.com/oauth2/authorize?{urlencode(params)}"
    return {"auth_url": auth_url}

@router.get("/auth/callback")
async def spreaker_callback(request: Request, code: str, state: str, db: Session = Depends(get_session)):
    stored_data = _oauth_states.pop(state, None)
    if not stored_data or stored_data["user_id"] is None:
        raise HTTPException(status_code=403, detail="Invalid state parameter")

    user_id = stored_data["user_id"]
    token_url = "https://api.spreaker.com/oauth2/token"
    data = {
        "grant_type": "authorization_code",
        "code": code,
        "client_id": settings.SPREAKER_CLIENT_ID,
        "client_secret": settings.SPREAKER_CLIENT_SECRET,
        "redirect_uri": settings.SPREAKER_REDIRECT_URI.replace("localhost", "127.0.0.1")
    }
    async with httpx.AsyncClient() as client:
        response = await client.post(token_url, data=data)
    
    if response.status_code != 200:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Failed to retrieve access token from Spreaker")
    
    token_data = response.json()
    user = crud.get_user_by_id(db, UUID(user_id))
    if not user:
        raise HTTPException(status_code=404, detail="User not found")

    user.spreaker_access_token = token_data["access_token"]
    user.spreaker_refresh_token = token_data["refresh_token"]
    db.add(user)
    db.commit()
    db.refresh(user)
    
    return HTMLResponse('''
        <html><head><title>Authentication Successful</title><script>
        window.opener.postMessage("spreaker_connected", "*");
        setTimeout(() => window.close(), 500);
        </script></head><body><p>Authentication successful! You can now close this window.</p></body></html>
    ''')

@router.post("/disconnect", status_code=status.HTTP_200_OK)
async def disconnect_spreaker(session: Session = Depends(get_session), current_user: User = Depends(get_current_user)):
    current_user.spreaker_access_token = None
    current_user.spreaker_refresh_token = None
    session.add(current_user)
    session.commit()
    session.refresh(current_user)
    return {"message": "Spreaker account disconnected successfully."}

@router.get("/shows")
async def get_spreaker_shows(current_user: User = Depends(get_current_user)):
    """
    Returns the authenticated user's Spreaker shows as:
    { "items": [ ... ] }
    """
    if not current_user.spreaker_access_token:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Spreaker not authenticated for this user."
        )

    try:
        client = SpreakerClient(api_token=current_user.spreaker_access_token)
        ok, result = client.get_shows()
        if not ok:
            # result is a human-readable error string from the client
            raise HTTPException(status_code=status.HTTP_502_BAD_GATEWAY, detail=f"Spreaker error: {result}")

        # Ensure JSON-serializable list
        if not isinstance(result, list):
            raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Unexpected shows payload from Spreaker.")

        return {"items": result}

    except HTTPException:
        raise
    except Exception as e:
        # Log and surface a clean 500
        import logging, traceback
        logging.getLogger(__name__).error("GET /spreaker/shows crashed: %s\n%s", e, traceback.format_exc())
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Internal server error while fetching Spreaker shows.")


@router.post("/upload")
async def upload_to_spreaker(
    payload: SpreakerUploadRequest,
    current_user: User = Depends(get_current_user)
):
    if not current_user.spreaker_access_token:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Spreaker not authenticated for this user.")

    file_path = await run_in_threadpool(find_file_in_dirs, payload.filename)
    if not file_path:
        raise HTTPException(status_code=404, detail=f"Finalized episode file not found: {payload.filename}")

    client = SpreakerClient(api_token=current_user.spreaker_access_token)
    
    success, result = await run_in_threadpool(
        client.upload_episode,
        show_id=payload.show_id,
        title=payload.title,
        file_path=str(file_path),
        description=payload.description,
        auto_published_at=payload.auto_published_at
    )

    if not success:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=result)

    return {"message": "Successfully uploaded to Spreaker", "details": result}
